<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Kalshi Event Detail</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,500;9..144,700&family=Space+Grotesk:wght@400;500;600;700&display=swap");

      :root {
        --ink: #1c2a2d;
        --ink-muted: #4f5f66;
        --ink-soft: #74818a;
        --accent: #e06b2f;
        --surface: #f9f2e6;
        --surface-2: #fffdf7;
        --border: #e6d6c1;
        --shadow: rgba(18, 23, 32, 0.14);
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Space Grotesk", "Trebuchet MS", sans-serif;
        color: var(--ink);
        background: radial-gradient(circle at 20% 10%, #fff3da 0%, #f7efe3 40%, #efe4d6 100%);
        min-height: 100vh;
      }

      .page {
        max-width: 1200px;
        margin: 0 auto;
        padding: 36px 24px 60px;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--ink);
        text-decoration: none;
        border: 1px solid var(--border);
        padding: 6px 12px;
        border-radius: 999px;
        background: white;
      }

      .kalshi-link {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--ink);
        text-decoration: none;
        border: 1px solid var(--border);
        padding: 6px 12px;
        border-radius: 999px;
        background: white;
        margin-left: 8px;
      }

      .hero {
        margin-top: 18px;
      }

      .eyebrow {
        text-transform: uppercase;
        letter-spacing: 0.2em;
        font-size: 12px;
        color: var(--ink-soft);
      }

      h1 {
        font-family: "Fraunces", "Georgia", serif;
        font-size: 38px;
        margin: 12px 0 8px;
      }

      .subtitle {
        color: var(--ink-muted);
        max-width: 600px;
        line-height: 1.5;
      }

      .status-row {
        margin-top: 10px;
      }

      .status-pill {
        display: inline-flex;
        align-items: center;
        border-radius: 999px;
        padding: 6px 14px;
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        border: 1px solid transparent;
      }

      .status-closed {
        background: rgba(32, 122, 191, 0.18);
        color: #0b4b7e;
        border-color: rgba(32, 122, 191, 0.35);
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
        gap: 18px;
        margin-top: 28px;
      }

      .card {
        background: var(--surface-2);
        border-radius: 18px;
        border: 1px solid var(--border);
        padding: 18px 20px;
        box-shadow: 0 16px 28px var(--shadow);
      }

      .card h2 {
        font-family: "Fraunces", "Georgia", serif;
        margin: 0 0 12px;
        font-size: 20px;
      }

      dl {
        margin: 0;
        display: grid;
        gap: 12px;
      }

      .row {
        display: grid;
        gap: 6px;
      }

      dt {
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        color: var(--ink-soft);
      }

      .help-label {
        position: relative;
        border-bottom: 1px dotted var(--ink-soft);
        cursor: help;
        display: inline-block;
      }

      .help-label::after {
        content: attr(data-tooltip);
        position: absolute;
        left: 50%;
        top: calc(100% + 10px);
        transform: translateX(-50%);
        background: #1c2a2d;
        color: #fff;
        font-size: 12px;
        line-height: 1.4;
        padding: 8px 10px;
        border-radius: 8px;
        width: max-content;
        max-width: 260px;
        text-align: left;
        opacity: 0;
        pointer-events: none;
        z-index: 5;
        box-shadow: 0 10px 24px rgba(18, 23, 32, 0.2);
      }

      .help-label::before {
        content: "";
        position: absolute;
        left: 50%;
        top: calc(100% + 4px);
        transform: translateX(-50%);
        border-width: 6px 6px 0 6px;
        border-style: solid;
        border-color: #1c2a2d transparent transparent transparent;
        opacity: 0;
        pointer-events: none;
        z-index: 6;
      }

      .help-label:hover::after,
      .help-label:hover::before {
        opacity: 1;
      }

      thead th:first-child .help-label::after {
        left: 0;
        transform: none;
      }

      thead th:first-child .help-label::before {
        left: 12px;
        transform: none;
      }

      thead th:last-child .help-label::after {
        left: auto;
        right: 0;
        transform: none;
      }

      thead th:last-child .help-label::before {
        left: auto;
        right: 12px;
        transform: none;
      }

      dd {
        margin: 0;
        font-size: 14px;
        color: var(--ink);
      }

      .table-card {
        margin-top: 28px;
        background: var(--surface-2);
        border-radius: 18px;
        border: 1px solid var(--border);
        box-shadow: 0 16px 28px var(--shadow);
        overflow: hidden;
      }

      .table-wrap {
        overflow-x: auto;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        min-width: 980px;
      }

      thead th {
        background: var(--surface);
        color: var(--ink-soft);
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        text-align: left;
        padding: 14px 18px;
      }

      tbody td {
        padding: 16px 18px;
        border-top: 1px solid var(--border);
        vertical-align: top;
        font-size: 14px;
        color: var(--ink);
      }

      .row-link {
        cursor: pointer;
      }

      .row-link:hover {
        background: #fff7ec;
      }

      .title-stack .title {
        font-weight: 600;
        margin-bottom: 4px;
      }

      .title-stack .meta {
        color: var(--ink-soft);
        font-size: 12px;
      }

      .links {
        margin-top: 6px;
        display: flex;
        gap: 12px;
        font-size: 12px;
      }

      .links a {
        color: var(--accent);
        text-decoration: none;
      }

      .freshness-pill {
        margin-top: 8px;
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        border-radius: 999px;
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        border: 1px solid transparent;
      }

      .freshness-ws {
        background: rgba(46, 163, 132, 0.18);
        color: #19684f;
        border-color: rgba(46, 163, 132, 0.35);
      }

      .freshness-snapshot {
        background: rgba(224, 107, 47, 0.16);
        color: #9c3f0f;
        border-color: rgba(224, 107, 47, 0.35);
      }

      .freshness-backfill {
        background: rgba(32, 122, 191, 0.18);
        color: #0b4b7e;
        border-color: rgba(32, 122, 191, 0.35);
      }

      .freshness-unknown {
        background: rgba(116, 129, 138, 0.16);
        color: #4f5f66;
        border-color: rgba(116, 129, 138, 0.3);
      }

      .sparkline-wrap {
        display: flex;
        align-items: center;
        min-height: 32px;
      }

      .sparkline {
        width: 120px;
        height: 32px;
        display: block;
      }

      .sparkline-empty {
        font-size: 12px;
        color: var(--ink-soft);
      }

      .snapshot-actions {
        margin-top: 12px;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .snapshot-button {
        border: 1px solid var(--border);
        background: white;
        color: var(--ink);
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.12em;
        padding: 6px 12px;
        border-radius: 999px;
        cursor: pointer;
      }

      .snapshot-button[disabled] {
        opacity: 0.6;
        cursor: wait;
      }

      .snapshot-status {
        font-size: 12px;
        color: var(--ink-soft);
      }

      .snapshot-status.error {
        color: #b24a2a;
      }

      .auto-refresh {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        margin-top: 10px;
        font-size: 12px;
        letter-spacing: 0.12em;
        text-transform: uppercase;
        color: var(--ink-soft);
      }

      .auto-refresh input {
        accent-color: var(--accent);
      }

      .auto-refresh-countdown {
        color: var(--ink);
        font-weight: 600;
      }

      .pricing-error {
        margin-top: 8px;
        color: #a24a12;
        font-size: 12px;
        line-height: 1.4;
      }

      .pricing-note {
        margin-top: 6px;
        color: #665040;
        font-size: 12px;
        line-height: 1.4;
      }

      .chart-card {
        display: flex;
        flex-direction: column;
      }

      .chart-wrap {
        width: 100%;
        height: 240px;
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .legend {
        margin-top: 12px;
        display: flex;
        flex-wrap: wrap;
        gap: 10px 16px;
        font-size: 12px;
        color: var(--ink-muted);
      }

      .legend-item {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }

      .legend-swatch {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        flex-shrink: 0;
      }

      .forecast-note {
        margin-top: 10px;
        font-size: 12px;
        color: var(--ink-soft);
      }

      .na {
        color: var(--ink-soft);
        font-size: 13px;
        padding: 10px 12px;
        background: var(--surface);
        border-radius: 12px;
        border: 1px dashed var(--border);
      }

      .empty {
        padding: 22px 18px;
        color: var(--ink-soft);
        font-size: 14px;
        background: var(--surface);
        border-top: 1px solid var(--border);
      }

      .alert {
        border: 1px solid rgba(224, 107, 47, 0.45);
        background: rgba(255, 239, 226, 0.9);
        padding: 16px 18px;
        border-radius: 14px;
        margin-top: 20px;
        box-shadow: 0 10px 20px var(--shadow);
      }
    </style>
  </head>
  <body>
    <div class="page">
      <a class="back-link" href="/">Back to events</a>
      {% if event and event.event_url %}
      <a class="kalshi-link" href="{{ event.event_url }}" target="_blank" rel="noopener">View on Kalshi</a>
      {% endif %}

      {% if error %}
      <div class="alert">{{ error }}</div>
      {% endif %}

      {% if event %}
      {% set event_label_help = {
        "Event title": "Full event question/title as listed by Kalshi.",
        "Event outcome": "Current leading outcome across markets (derived from latest pricing).",
        "Event ticker": "Unique event identifier used by Kalshi.",
        "Event subtitle": "Short descriptor shown under the event title on Kalshi.",
        "Category": "Top-level category assigned by Kalshi.",
        "Series ticker": "Series identifier that groups related events.",
        "Strike date": "Date the event resolves (if provided).",
        "Strike period": "Resolution cadence such as hour or day.",
        "Mutually exclusive": "If true, only one market outcome can resolve YES.",
        "Available on brokers": "Whether the event is tradable through brokers.",
        "Markets": "Total number of markets/outcomes in this event.",
        "Volume": "Sum of the latest market volumes across outcomes.",
        "Open time": "Earliest market open time across the event.",
        "Close time": "Latest market close time across the event."
      } %}
      <div class="hero">
        <div class="eyebrow">Event Detail</div>
        <h1>{{ event.event_title }}</h1>
        {% if event.event_is_closed %}
        <div class="status-row">
          <div class="status-pill status-closed">Closed</div>
        </div>
        {% endif %}
        {% if event.event_subtitle %}
        <div class="subtitle">{{ event.event_subtitle }}</div>
        {% endif %}
      </div>
      <div class="snapshot-actions">
        <button class="snapshot-button" id="eventSnapshotButton" type="button">
          Fetch live snapshots
        </button>
        <div class="snapshot-status" id="eventSnapshotStatus">Ready</div>
      </div>
      {% if not event.event_is_closed %}
      <label class="auto-refresh">
        <input type="checkbox" id="eventAutoRefreshToggle" />
        Auto refresh every <span id="eventAutoRefreshInterval">120</span>s
        <span class="auto-refresh-countdown" id="eventAutoRefreshCountdown">| next in 120s</span>
      </label>
      {% endif %}

      {% if event.ticks_missing or event.pricing_errors %}
      <div class="alert">
        {% if event.ticks_missing %}
        No real-time ticks yet. If this market is open, make sure
        <code>KALSHI_WS_ENABLE=1</code> in <code>kalshi_ingestor/.env</code>
        and confirm <code>market_ticks</code> populates.
        {% else %}
        Pricing data is missing for one or more outcomes.
        {% endif %}
      </div>
      {% endif %}

      <section class="grid">
        <div class="card">
          <h2>
            <span class="help-label" data-tooltip="Summary metadata pulled from Kalshi for this event.">
              Event Overview
            </span>
          </h2>
          <dl>
            {% for label, value in event.event_fields %}
            <div class="row">
              <dt>
                {% set help_text = event_label_help.get(label) %}
                {% if help_text %}
                  <span class="help-label" data-tooltip="{{ help_text }}">{{ label }}</span>
                {% else %}
                  {{ label }}
                {% endif %}
              </dt>
              <dd>{{ value }}</dd>
            </div>
            {% endfor %}
          </dl>
        </div>
        <div class="card chart-card">
          <h2>Forecast Over Time</h2>
          {% if event.forecast_series %}
          <div class="chart-wrap">
            <canvas id="eventForecastChart"></canvas>
          </div>
          <div class="legend">
            {% for series in event.forecast_series %}
            <div class="legend-item">
              <span class="legend-swatch" style="background: {{ series.color }};"></span>
              <span>{{ series.label }}</span>
            </div>
            {% endfor %}
          </div>
          {% if event.forecast_note %}
          <div class="forecast-note">{{ event.forecast_note }}</div>
          {% endif %}
          {% else %}
          <div class="na">No forecast history available.</div>
          {% endif %}
        </div>
      </section>

      <section class="table-card">
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>
                  <span class="help-label" data-tooltip="Outcome label and market ticker for this row.">
                    Outcome
                  </span>
                </th>
                <th>
                  <span class="help-label" data-tooltip="Recent YES-price movement for this outcome (sparkline).">
                    Trend
                  </span>
                </th>
                <th>
                  <span class="help-label" data-tooltip="Latest implied YES probability from live pricing.">
                    Chance
                  </span>
                </th>
                <th>
                  <span class="help-label" data-tooltip="Agent model forecast for YES, plus confidence or last update.">
                    Agent
                  </span>
                </th>
                <th>
                  <span class="help-label" data-tooltip="Latest market volume for the outcome.">
                    Volume
                  </span>
                </th>
                <th>
                  <span class="help-label" data-tooltip="Best current bid price for YES.">
                    Yes Bid
                  </span>
                </th>
                <th>
                  <span class="help-label" data-tooltip="Best current bid price for NO (derived from YES prices when needed).">
                    No Bid
                  </span>
                </th>
              </tr>
            </thead>
            <tbody>
              {% set visible_outcomes = (event.outcomes or []) | rejectattr("volume", "equalto", "N/A") | list %}
              {% if event.event_is_open %}
                {% set visible_outcomes = visible_outcomes | rejectattr("volume", "equalto", "0") | list %}
              {% endif %}
              {% if visible_outcomes %}
                {% for outcome in visible_outcomes %}
                <tr class="row-link" data-href="{{ url_for('market.market_detail', ticker=outcome.market_ticker) }}">
                  <td>
                    <div class="title-stack">
                      <div class="title">{{ outcome.chance_label }}</div>
                      <div class="meta">{{ outcome.market_ticker }}</div>
                    </div>
                    <div class="links">
                      <a href="{{ url_for('market.market_detail', ticker=outcome.market_ticker) }}">Details</a>
                    </div>
                    {% if outcome.pricing_error %}
                    <div class="pricing-error">{{ outcome.pricing_error }}</div>
                    {% endif %}
                    {% if outcome.liquidity_note %}
                    <div class="pricing-note">{{ outcome.liquidity_note }}</div>
                    {% endif %}
                    <div class="freshness-pill freshness-{{ outcome.freshness_source }}">
                      {{ outcome.freshness_label }}
                      {% if outcome.freshness_age_label %}
                        {{ outcome.freshness_age_label }}
                      {% endif %}
                    </div>
                  </td>
                  <td>
                    <div class="sparkline-wrap">
                      {% if outcome.sparkline_points and outcome.sparkline_points | length > 1 %}
                      <canvas class="sparkline" data-points='{{ outcome.sparkline_json }}'></canvas>
                      {% else %}
                      <div class="sparkline-empty">No ticks</div>
                      {% endif %}
                    </div>
                  </td>
                  <td>{{ outcome.chance_percent }}</td>
                  <td>
                    <div class="title-stack">
                      <div class="title">{{ outcome.agent_percent }}</div>
                      {% if outcome.agent_confidence and outcome.agent_confidence != "--" %}
                      <div class="meta">Conf {{ outcome.agent_confidence }}</div>
                      {% elif outcome.agent_updated and outcome.agent_updated != "N/A" %}
                      <div class="meta">{{ outcome.agent_updated }}</div>
                      {% endif %}
                    </div>
                  </td>
                  <td>{{ outcome.volume }}</td>
                  <td>{{ outcome.yes_bid }}</td>
                  <td>{{ outcome.no_bid }}</td>
                </tr>
                {% endfor %}
              {% else %}
                <tr>
                  <td colspan="7" class="empty">No outcomes with volume data for this event.</td>
                </tr>
              {% endif %}
            </tbody>
          </table>
        </div>
      </section>
      {% else %}
      <div class="alert">No event detail found.</div>
      {% endif %}
    </div>
    <script>
      document.querySelectorAll(".row-link").forEach((row) => {
        row.addEventListener("click", (event) => {
          if (event.target.closest("a")) {
            return;
          }
          const href = row.getAttribute("data-href");
          if (href) {
            window.location.href = href;
          }
        });
      });
    </script>
    <script>
      function parseSparklinePoints(raw) {
        if (!raw) {
          return [];
        }
        try {
          const parsed = JSON.parse(raw);
          if (!Array.isArray(parsed)) {
            return [];
          }
          return parsed.map((value) => Number(value)).filter((value) => Number.isFinite(value));
        } catch (err) {
          return [];
        }
      }

      function drawSparkline(canvas) {
        if (!canvas) {
          return;
        }
        const points = parseSparklinePoints(canvas.dataset.points);
        const ctx = canvas.getContext("2d");
        const dpr = window.devicePixelRatio || 1;
        const width = canvas.clientWidth || 120;
        const height = canvas.clientHeight || 32;
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, width, height);

        if (points.length < 2) {
          ctx.strokeStyle = "rgba(116, 129, 138, 0.45)";
          ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.moveTo(4, height / 2);
          ctx.lineTo(width - 4, height / 2);
          ctx.stroke();
          ctx.setLineDash([]);
          return;
        }

        const values = points.map((value) => Math.max(0, Math.min(1, value)));
        let minVal = Math.min(...values);
        let maxVal = Math.max(...values);
        if (maxVal - minVal < 0.02) {
          minVal = Math.max(0, minVal - 0.01);
          maxVal = Math.min(1, maxVal + 0.01);
        }
        const range = maxVal - minVal || 1;
        const pad = 4;
        const step = (width - pad * 2) / (values.length - 1);

        ctx.beginPath();
        values.forEach((value, idx) => {
          const x = pad + idx * step;
          const y = pad + (1 - (value - minVal) / range) * (height - pad * 2);
          if (idx === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        const trendUp = values[values.length - 1] >= values[0];
        ctx.strokeStyle = trendUp ? "#2ea384" : "#e06b2f";
        ctx.lineWidth = 1.6;
        ctx.stroke();

        const lastX = pad + (values.length - 1) * step;
        const lastY = pad + (1 - (values[values.length - 1] - minVal) / range) * (height - pad * 2);
        ctx.fillStyle = ctx.strokeStyle;
        ctx.beginPath();
        ctx.arc(lastX, lastY, 2.5, 0, Math.PI * 2);
        ctx.fill();
      }

      function drawAllSparklines() {
        document.querySelectorAll(".sparkline").forEach((canvas) => {
          drawSparkline(canvas);
        });
      }

      drawAllSparklines();
      window.addEventListener("resize", () => {
        window.requestAnimationFrame(drawAllSparklines);
      });
    </script>
    {% if event and event.forecast_series %}
    <script>
      const forecastSeries = {{ event.forecast_series_json | safe }};
      const forecastCanvas = document.getElementById("eventForecastChart");
      if (forecastCanvas && Array.isArray(forecastSeries) && forecastSeries.length) {
        const ctx = forecastCanvas.getContext("2d");
        const container = forecastCanvas.parentElement;
        const dpr = window.devicePixelRatio || 1;

        function normalizeSeries(rawSeries) {
          return rawSeries
            .map((series) => {
              const points = (series.points || [])
                .map((point) => {
                  const ts = new Date(point.ts);
                  const value = Number(point.value);
                  if (!Number.isFinite(value) || Number.isNaN(ts.getTime())) {
                    return null;
                  }
                  return { ts: ts.getTime(), value };
                })
                .filter(Boolean)
                .sort((a, b) => a.ts - b.ts);
              return {
                label: series.label || series.ticker || "Outcome",
                color: series.color || "#4f5f66",
                points,
              };
            })
            .filter((series) => series.points.length > 1);
        }

        const seriesData = normalizeSeries(forecastSeries);

        function resizeForecastCanvas() {
          const width = container.clientWidth;
          const height = container.clientHeight;
          forecastCanvas.width = Math.floor(width * dpr);
          forecastCanvas.height = Math.floor(height * dpr);
          forecastCanvas.style.width = width + "px";
          forecastCanvas.style.height = height + "px";
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          drawForecast();
        }

        function drawForecast() {
          const width = container.clientWidth;
          const height = container.clientHeight;
          ctx.clearRect(0, 0, width, height);

          if (!seriesData.length) {
            ctx.fillStyle = "#74818a";
            ctx.fillText("No forecast data", 12, 24);
            return;
          }

          const allPoints = seriesData.flatMap((series) => series.points);
          const minTs = Math.min(...allPoints.map((point) => point.ts));
          const maxTs = Math.max(...allPoints.map((point) => point.ts));
          const minValRaw = Math.min(...allPoints.map((point) => point.value));
          const maxValRaw = Math.max(...allPoints.map((point) => point.value));
          let minVal = Math.max(0, minValRaw - 0.05);
          let maxVal = Math.min(1, maxValRaw + 0.05);
          if (maxVal - minVal < 0.05) {
            maxVal = Math.min(1, minVal + 0.1);
          }
          const range = maxVal - minVal || 1;
          const padding = {
            top: 18,
            right: 20,
            bottom: 34,
            left: 48,
          };
          const chartWidth = width - padding.left - padding.right;
          const chartHeight = height - padding.top - padding.bottom;
          const chartLeft = padding.left;
          const chartBottom = height - padding.bottom;

          function xFor(ts) {
            if (maxTs === minTs) {
              return chartLeft;
            }
            return chartLeft + (ts - minTs) / (maxTs - minTs) * chartWidth;
          }

          function yFor(value) {
            return padding.top + (maxVal - value) / range * chartHeight;
          }

          const gridColor = "rgba(28, 42, 45, 0.08)";
          const axisColor = "rgba(28, 42, 45, 0.35)";
          ctx.lineWidth = 1;
          ctx.strokeStyle = gridColor;

          const yTickCount = 4;
          for (let i = 0; i <= yTickCount; i += 1) {
            const value = minVal + (range / yTickCount) * i;
            const y = yFor(value);
            ctx.beginPath();
            ctx.moveTo(chartLeft, y);
            ctx.lineTo(width - padding.right, y);
            ctx.stroke();
          }

          seriesData.forEach((series) => {
            ctx.beginPath();
            series.points.forEach((point, idx) => {
              const x = xFor(point.ts);
              const y = yFor(point.value);
              if (idx === 0) {
                ctx.moveTo(x, y);
              } else {
                ctx.lineTo(x, y);
              }
            });
            ctx.strokeStyle = series.color;
            ctx.lineWidth = 2;
            ctx.stroke();

            const lastPoint = series.points[series.points.length - 1];
            if (lastPoint) {
              ctx.fillStyle = series.color;
              ctx.beginPath();
              ctx.arc(xFor(lastPoint.ts), yFor(lastPoint.value), 3, 0, Math.PI * 2);
              ctx.fill();
            }
          });

          ctx.strokeStyle = axisColor;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(chartLeft, padding.top);
          ctx.lineTo(chartLeft, chartBottom);
          ctx.lineTo(width - padding.right, chartBottom);
          ctx.stroke();

          ctx.font = "11px \"Space Grotesk\", \"Trebuchet MS\", sans-serif";
          ctx.fillStyle = "#4f5f66";
          ctx.textAlign = "right";
          ctx.textBaseline = "middle";

          for (let i = 0; i <= yTickCount; i += 1) {
            const value = minVal + (range / yTickCount) * i;
            const y = yFor(value);
            ctx.strokeStyle = axisColor;
            ctx.beginPath();
            ctx.moveTo(chartLeft - 6, y);
            ctx.lineTo(chartLeft, y);
            ctx.stroke();
            const label = `${Math.round(value * 100)}%`;
            ctx.fillText(label, chartLeft - 8, y);
          }

          const times = Array.from(new Set(allPoints.map((point) => point.ts)))
            .sort((a, b) => a - b);
          const xTickCount = Math.min(5, times.length);
          const xTickIndexes = new Set();
          if (xTickCount === 1) {
            xTickIndexes.add(times.length - 1);
          } else {
            for (let i = 0; i < xTickCount; i += 1) {
              const idx = Math.round(i * (times.length - 1) / (xTickCount - 1));
              xTickIndexes.add(idx);
            }
          }

          const showTime = maxTs - minTs <= 36 * 60 * 60 * 1000;
          function formatTsLabel(ts) {
            const dt = new Date(ts);
            if (Number.isNaN(dt.getTime())) {
              return "";
            }
            if (showTime) {
              return dt.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
            }
            return dt.toLocaleDateString([], { month: "short", day: "numeric" });
          }

          ctx.textAlign = "center";
          ctx.textBaseline = "top";
          ctx.strokeStyle = axisColor;
          Array.from(xTickIndexes)
            .sort((a, b) => a - b)
            .forEach((idx) => {
              const ts = times[idx];
              const x = xFor(ts);
              ctx.beginPath();
              ctx.moveTo(x, chartBottom);
              ctx.lineTo(x, chartBottom + 6);
              ctx.stroke();
              const label = formatTsLabel(ts);
              if (label) {
                ctx.fillText(label, x, chartBottom + 8);
              }
            });
        }

        window.addEventListener("resize", resizeForecastCanvas);
        resizeForecastCanvas();
      }
    </script>
    {% endif %}
    {% if event %}
    <script>
      const eventSnapshotButton = document.getElementById("eventSnapshotButton");
      const eventSnapshotStatus = document.getElementById("eventSnapshotStatus");
      const autoRefreshToggle = document.getElementById("eventAutoRefreshToggle");
      const autoRefreshIntervalEl = document.getElementById("eventAutoRefreshInterval");
      const autoRefreshCountdownEl = document.getElementById("eventAutoRefreshCountdown");
      const autoSnapshotIntervalSec = {{ auto_snapshot_sec }};
      const eventTicker = {{ event.event_ticker | tojson }};
      const autoRefreshKey = "eventAutoRefreshEnabled";
      const autoRefreshDefault = true;
      const snapshotHistoryKey = `eventSnapshotLastFetch:${eventTicker}`;
      const autoRefreshOffsetSec = computeAutoRefreshOffset(eventTicker, autoSnapshotIntervalSec);
      let autoRefreshTimer = null;
      let autoRefreshCountdownTimer = null;
      let nextAutoRefreshAt = null;
      let autoRefreshEnabled = false;
      let snapshotInFlight = false;
      {% if event.event_is_closed %}
      const eventSnapshotUrl = "{{ url_for('event.event_snapshot', event_ticker=event.event_ticker, include_closed=1) }}";
      {% else %}
      const eventSnapshotUrl = "{{ url_for('event.event_snapshot', event_ticker=event.event_ticker) }}";
      {% endif %}

      function setEventSnapshotStatus(message, isError = false) {
        if (!eventSnapshotStatus) {
          return;
        }
        eventSnapshotStatus.textContent = message;
        eventSnapshotStatus.classList.toggle("error", isError);
      }

      function loadLastSnapshotAt() {
        if (!snapshotHistoryKey) {
          return null;
        }
        const raw = localStorage.getItem(snapshotHistoryKey);
        if (!raw) {
          return null;
        }
        const parsed = Number(raw);
        return Number.isFinite(parsed) ? parsed : null;
      }

      function saveLastSnapshotAt(ts) {
        if (!snapshotHistoryKey || !Number.isFinite(ts)) {
          return;
        }
        localStorage.setItem(snapshotHistoryKey, String(Math.floor(ts)));
      }

      async function fetchEventSnapshot(options = {}) {
        if (!eventSnapshotButton) {
          return;
        }
        if (snapshotInFlight) {
          return;
        }
        snapshotInFlight = true;
        eventSnapshotButton.disabled = true;
        const isAuto = Boolean(options.auto);
        setEventSnapshotStatus(isAuto ? "Auto refresh in progress..." : "Fetching live snapshots...");
        try {
          const response = await fetch(eventSnapshotUrl, {
            headers: { Accept: "application/json" },
            cache: "no-store",
          });
          const contentType = response.headers.get("content-type") || "";
          let data = null;
          if (contentType.includes("application/json")) {
            data = await response.json();
          } else {
            const text = await response.text();
            if (!response.ok) {
              throw new Error("Live snapshot request failed.");
            }
            throw new Error(text || "Live snapshot response was not JSON.");
          }
          if (!response.ok) {
            const message = data && (data.error || data.message);
            throw new Error(message || "Live snapshot request failed.");
          }
          if (data.error) {
            throw new Error(data.error);
          }
          const errorList = Array.isArray(data.errors) ? data.errors : [];
          if (errorList.length) {
            const preview = errorList
              .slice(0, 3)
              .map((item) => `${item.ticker}: ${item.error}`)
              .join(" | ");
            const suffix = errorList.length > 3 ? " ..." : "";
            setEventSnapshotStatus(
              `Fetched ${data.updated || 0} of ${data.requested || 0}. Errors: ${preview}${suffix} Reload to see updates.`,
              true
            );
          } else {
            setEventSnapshotStatus(
              `Fetched ${data.updated || 0} of ${data.requested || 0}. Reloading...`
            );
            saveLastSnapshotAt(Date.now());
            setTimeout(() => window.location.reload(), 600);
          }
        } catch (err) {
          setEventSnapshotStatus(err.message || "Live snapshot failed.", true);
        } finally {
          eventSnapshotButton.disabled = false;
          snapshotInFlight = false;
        }
      }

      if (eventSnapshotButton) {
        eventSnapshotButton.addEventListener("click", fetchEventSnapshot);
      }

      function startAutoRefresh() {
        if (!autoSnapshotIntervalSec || autoSnapshotIntervalSec < 10) {
          return;
        }
        stopAutoRefresh();
        scheduleNextAutoRefresh();
      }

      function stopAutoRefresh() {
        if (autoRefreshTimer) {
          clearTimeout(autoRefreshTimer);
          autoRefreshTimer = null;
        }
      }

      function setAutoRefreshCountdown(text) {
        if (!autoRefreshCountdownEl) {
          return;
        }
        autoRefreshCountdownEl.textContent = text ? `| ${text}` : "";
      }

      function stopAutoRefreshCountdown() {
        if (autoRefreshCountdownTimer) {
          clearInterval(autoRefreshCountdownTimer);
          autoRefreshCountdownTimer = null;
        }
      }

      function updateAutoRefreshCountdown() {
        if (!nextAutoRefreshAt) {
          return;
        }
        const remainingMs = nextAutoRefreshAt - Date.now();
        const remainingSec = Math.max(0, Math.ceil(remainingMs / 1000));
        setAutoRefreshCountdown(`next in ${remainingSec}s`);
      }

      function startAutoRefreshCountdown() {
        if (!autoRefreshCountdownEl) {
          return;
        }
        stopAutoRefreshCountdown();
        autoRefreshCountdownTimer = setInterval(updateAutoRefreshCountdown, 1000);
        updateAutoRefreshCountdown();
      }

      function scheduleNextAutoRefresh() {
        if (!autoSnapshotIntervalSec || autoSnapshotIntervalSec < 10) {
          nextAutoRefreshAt = null;
          stopAutoRefreshCountdown();
          setAutoRefreshCountdown("disabled");
          return;
        }
        const delayMs = nextAlignedDelayMs();
        nextAutoRefreshAt = Date.now() + delayMs;
        startAutoRefreshCountdown();
        if (autoRefreshTimer) {
          clearTimeout(autoRefreshTimer);
        }
        autoRefreshTimer = setTimeout(() => {
          autoRefreshTimer = null;
          if (!autoRefreshEnabled) {
            return;
          }
          if (!document.hidden) {
            fetchEventSnapshot({ auto: true });
          }
          scheduleNextAutoRefresh();
        }, delayMs);
      }

      function computeAutoRefreshOffset(seed, intervalSec) {
        if (!seed || !intervalSec) {
          return 0;
        }
        let hash = 0;
        for (let i = 0; i < seed.length; i += 1) {
          hash = (hash * 31 + seed.charCodeAt(i)) % intervalSec;
        }
        return hash;
      }

      function nextAlignedDelayMs() {
        const intervalMs = autoSnapshotIntervalSec * 1000;
        const offsetMs = autoRefreshOffsetSec * 1000;
        const now = Date.now();
        const mod = ((now - offsetMs) % intervalMs + intervalMs) % intervalMs;
        return mod === 0 ? intervalMs : intervalMs - mod;
      }

      function setAutoRefresh(enabled) {
        autoRefreshEnabled = enabled;
        localStorage.setItem(autoRefreshKey, enabled ? "1" : "0");
        if (enabled) {
          if (!autoSnapshotIntervalSec || autoSnapshotIntervalSec < 10) {
            setAutoRefreshCountdown("disabled");
            return;
          }
          const lastSnapshotAt = loadLastSnapshotAt();
          const minIntervalMs = autoSnapshotIntervalSec * 1000;
          const shouldFetchNow =
            !lastSnapshotAt || Date.now() - lastSnapshotAt >= minIntervalMs;
          if (shouldFetchNow) {
            fetchEventSnapshot({ auto: true });
          }
          startAutoRefresh();
        } else {
          stopAutoRefresh();
          nextAutoRefreshAt = null;
          stopAutoRefreshCountdown();
          setAutoRefreshCountdown("paused");
        }
      }

      if (autoRefreshIntervalEl) {
        autoRefreshIntervalEl.textContent = String(autoSnapshotIntervalSec);
      }

      if (autoRefreshToggle) {
        const stored = localStorage.getItem(autoRefreshKey);
        const enabled = stored === null ? autoRefreshDefault : stored === "1";
        autoRefreshToggle.checked = enabled;
        if (enabled) {
          setAutoRefresh(true);
        } else {
          setAutoRefreshCountdown("paused");
        }
        autoRefreshToggle.addEventListener("change", () => {
          setAutoRefresh(autoRefreshToggle.checked);
        });
      }

      document.addEventListener("visibilitychange", () => {
        if (!document.hidden && autoRefreshEnabled) {
          if (!nextAutoRefreshAt || Date.now() >= nextAutoRefreshAt) {
            fetchEventSnapshot({ auto: true });
            scheduleNextAutoRefresh();
          }
        }
      });

    </script>
    {% endif %}
    {% include "queue_stream.html" %}
  </body>
</html>
